import re
import random
import string

from exceptions import InvalidTinyTextException, InvalidURLException


class URL(object):
    """
    The representation of the Tiny URL

    Inclides logic to validate the url (documented below) and logic to autogenerate the tiny_text if not provided.

    :param str url: The url we're creating the TinyURL for (must be fully qualified, e.g. http://www.google.com/
    :param str tiny_text: The text to be used as the tinyURL (optional, autogenerated on put if not provided)
    :param str prefix: Text to prefix the tiny_texy with
    :param str prefix_separator: The text used to separate the prefix and tiny_text.
    .. warning::  If a prefix is provided without a prefix_separator, the prefix \
    is directly prepended to the tiny_text. This may be desirable, but note that a defined a separator is the only way \
    to differentiate between the prefix and the auto-generated tiny_text upon reinstantiation. For example, creating a \
    url with the prefix 123 and an auto-generatred tiny_text of as12sd will create the url 123as12sd and upon \
    reinstantiation (like when listing) Stiny will have no way to differentiate between the prefix and tiny_text and \
    will assume it is all tiny_text.

    :ivar str url: The URL being pointed to by the tiny url.
    :ivar str prefix: The prefix to prepend to the tiny_text
    :ivar str prefix_separator: The separator used to separate the prefix from the tiny_text.
    :ivar str tiny_text: The tiny text used to create the tiny url without the prefix and separator and therefore not \
    the name of the object in the backing store. (see: :func:`get_tiny_uri`)
    :ivar bool tiny_text_provided: Whether the tiny_text was provided on instantiation or has been set at a later time
    """

    def __init__(self, url, tiny_text=None, prefix=None, prefix_separator=""):
        self._url = None
        self.url = url
        self._prefix = None
        self.prefix = prefix
        self.prefix_separator = prefix_separator
        self._tiny_text = None
        self.tiny_text = tiny_text
        self.tiny_text_provided = tiny_text is not None
        self.last_modified = None

    @property
    def url(self):
        """
        The url being alised by the tiny.

        :setter: Performs a regex match (:func:`_url_valid`) on the url
        :getter: returns the URL as a string
        :type: str
        """
        return self._url

    @url.setter
    def url(self, href):
        if self._url_valid(href):
            self._url = href
        else:
            raise InvalidURLException("{} is an invalid url".format(href))

    @staticmethod
    def _url_valid(url):
        """
        While this is a private member, it is included in documentation to demonstrate how urls are validated (and how \
        validation can be modified). This is called upon instantiation and url change.

        The URL validation regex is as follows::

            regex = re.compile(
                r'^(?:http|ftp)s?://'  # http:// or https://
                r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|'  # domain...
                r'localhost|'  # localhost...
                r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'  # ...or ip
                r'(?::\d+)?'  # optional port
                r'(?:/?|[/?]\S+)$', re.IGNORECASE)

        The validation is a simple match on this regex (which is basically stolen from django

        :param str url: The url to be validated
        :return: Whether the url matches the regex
        :rtype: bool
        """
        regex = re.compile(
            r'^(?:http|ftp)s?://'  # http:// or https://
            r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|'  # domain...
            r'localhost|'  # localhost...
            r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'  # ...or ip
            r'(?::\d+)?'  # optional port
            r'(?:/?|[/?]\S+)$', re.IGNORECASE)

        match = regex.match(url)
        return match is not None

    @property
    def tiny_text(self):
        # noinspection PyPep8
        """
                The tiny_text to be used for URL creation with a smart setter

                :setter: Parses the provided tiny_text for the prefix_separator. If present, sets the prefix and the tiny_text \
                otherwise only sets the tiny text.
                :return: tiny_text
                :rtype: str
                :raises: :class:`stiny.exceptions.InvalidTinyTextException` - if the tiny_text provided is not comprised of alpha-numerics.
                """
        return self._tiny_text

    @tiny_text.setter
    def tiny_text(self, tiny_text):
        if isinstance(tiny_text, (str, unicode)) and self.prefix_separator in tiny_text:
            try:
                tiny_split = tiny_text.split(self.prefix_separator)
                if len(tiny_split) == 2:
                    self.prefix = tiny_split[0]
                    tiny_text = tiny_split[1]
            except ValueError:
                # the separator is empty and we don't need to attempt to set the prefix
                pass

        if tiny_text is None or tiny_text.isalnum():
            self._tiny_text = tiny_text
        else:
            raise InvalidTinyTextException("{} is invalid tiny text".format(tiny_text))

    def get_tiny_uri(self):
        """
        Provides the full uri for the represented tinyurl. This is often the name of the object in the backing store.

        :return: prefix + prefix_separator + tiny_text
        :rtype: str
        """
        prefix = self.prefix + self.prefix_separator if self.prefix else ""
        return prefix + self._tiny_text

    def generate_tiny_text(self, length):
        """
        Generates random tiny_text of the length provided. Used by :class:`stiny.controllers.Controller` to create \
        the tiny_text if not provided.

        :param int length: The length of random tiny_text to generate
        :return: randomly generated tiny_text
        :rtype: str
        """
        prefix = self.prefix + self.prefix_separator if self.prefix else ""
        # noinspection PyUnusedLocal
        return prefix + "".join(random.choice(string.digits + string.letters) for i in range(int(length)))

    @property
    def prefix(self):
        return self._prefix

    @prefix.setter
    def prefix(self, prefix):
        if prefix is None:
            self._prefix = ""
        else:
            self._prefix = str(prefix)


